# WARNING - Generated by {fusen} from dev/flat_minimal.Rmd: do not edit by hand

#' Cluster Random Sample Size
#' 
#' Gives the number of clusters (pairs of clusters for paired designs) required for cluster randomized trials
#' 
#' @param alpha significance level
#' @param power the desired power
#' @param coef_var between-cluster variation, use 0.25 if unknown as this is the estimated maximum
#' @param A Adjustment for loss of degrees of freedom (1 for unpaired trials, 2 in paired trials)
#' @param pi proportion in the intervention group
#' @param pc proportion in the control group
#' @param CS an estimate of the cluster size
#'
#' @return number of clusters required in each treatment group in an unmatched design, and total pairs in a paired design.
#' @references Hayes, R. J., & Moulton, L. H. (2017). Cluster randomised trials. Chapman and Hall/CRC.
#' 
#' @export
#' @examples
#'
#' # The matched trial protocol required 80% power of detecting a 50% reduction of annual HIV incidence from an assumed 1% in the control arm (π0 = 0.02 over 2 years) to 0.5% in the intervention arm (π1 = 0.01). Thus, with m = 1000 adults followed up in each cluster, the number of clusters required per treatment arm in a matched design was gives 6.8 = 7 cluster pairs
#' cluster_random_sample_size(alpha=0.05, power=0.8, coef_var=0.25, A =2, pi=0.01, pc=0.02, CS=1000)
cluster_random_sample_size <- function(alpha, power, coef_var=0.25, A=2, pi, pc, CS){
  alpha_val <- 1-alpha/2
  qq <- ( qnorm(alpha_val) +qnorm(power))^2
  i <- pi*(1-pi)/CS
  c <- pc*(1-pc)/CS
  s <- (coef_var^2)*(pi^2 + pc^2)
  f <-(i+c+s)/((pi-pc)^2)
  N <- A + qq*f
  return(ceiling(N))

}

#' Effective Sample Size
#' 
#' Gives the 'real' sample size in a clustered trial, accounting for the net loss of data due to the similarities among participants in the same cluster. 
#' @param m number of participants in a cluster
#' @param k number of clusters
#' @param ICC intracluster correlation coefficient
#' 
#' @return effective sample size (actual sample size (mk) divided by the design effect (1 + ICC * (m - 1)))
#' 
#' @references Killip S, Mahfoud Z, Pearce K. (2004). What is an intracluster correlation coefficient? Crucial concepts for primary care researchers. Ann Fam Med. 
#' 
#' @export
#' @examples
#'
#' # In a cluster randomized controlled trial, you have 8 clusters with 30 participants per cluster i.e., total sample size of 240 and an ICC of 0.2. A simple method to calculate the power associated with this sample size is to first calculate the effective sample size i.e., the sample size in a simple random sample that would give the same level of precision, and then do a power calculation using the ESS. 
#'
#' effective_sample_size(m = 30, k =8, ICC = 0.2)
#'
effective_sample_size <- function(m, k, ICC){
  ss = m*k
  de = (1 + ICC * (m - 1))
  N = ss/de
  return(ceiling(N))
}


#' Generate power curve
#' 
#' Calls sample_size_calculation twice to calculate the number of confirmed cases and number of participants to be screened for a sequence of desired powers.
#' 
#' @param seq A sequence of statistical powers for which sample size is to be calculated
#' @param sen_spe expected sensitivity/specificity
#' @param alpha significance level
#' @param margin error margin (half width of the confidence interval)
#' @param prevalence expected disease prevalence
#' @param prevalence_power power to predict the prevalence
#' @param performance_characteristic the performance characteristic that is being evaluated
#'
#' @return A data frame with values ready to plot a power curve
#' 
#' @export
#' @examples
#' pow_list <- c(0.8, 0.85, 0.9, 0.95)
#'     dt <- gen_pow_curve(seq = pow_list,
#'                         sen_spe = 0.9,
#'                         alpha = 0.05,
#'                         margin = 0.05,
#'                         prevalence = 0.4,
#'                         prevalence_power = 0.8 ,
#'                         performance_characteristic = "sen")
gen_pow_curve <- function(seq, sen_spe, alpha, margin,
                          prevalence, prevalence_power, performance_characteristic = "sen"){

  dt <- data.frame()
  for (pow in seq) {
    #browser()
    n <- sample_size_calculation(sen_spe = sen_spe,
                                 alpha = alpha,
                                 power = pow,
                                 margin = margin,
                                 prevalence = NULL,
                                 prevalence_power = NULL ,
                                 performance_characteristic = performance_characteristic)
    N <- sample_size_calculation(sen_spe = sen_spe,
                                 alpha = alpha,
                                 power = pow,
                                 margin = margin,
                                 prevalence = prevalence,
                                 prevalence_power = prevalence_power ,
                                 performance_characteristic = performance_characteristic)
    table <- data.frame(`Power (%)` = pow*100 ,`n confirmed cases` = n, `n to screen` = N, check.names = FALSE )
    dt <- rbind(dt, table)
  }
  return(dt)
}


#' Sample Size Population Proportion
#'
#' @param alpha numeric, significance level
#' @param p   numeric, estimated proportion
#' @param margin numeric, error margin
#' @param N numeric, population size
#'
#' @return sample size for the estimation of the proportion
#' @export
#'
#' @references Daniel  WW  (1999).  Biostatistics:  A  Foundation for   Analysis   in   the   Health   Sciences.   7th edition. New York: John Wiley & Sons.
#'
#' @examples
#'
#'  n_pop_prop(alpha = 0.05, p =  0.5, margin = 0.1, N = 1000) 
#'
#' # sample size for a population of 1000 people to estimate that at least half of the population has the desired characteristic with an error margin of 10%
#'
#'  n_pop_prop(alpha = 0.05, p =  0.5, margin = 0.1) 
#'  # same calculation in an infinite population
n_pop_prop <- function(alpha, p, margin, N=NULL) {
  alpha_val         <- 1-alpha/2
  X <- qnorm(alpha_val)^2 * p * (1-p) / margin^2
  if (is.null(N)){
      n = X
  } else {
      n = N*X / (X + N-1)
  }
  return(ceiling(n))
}

